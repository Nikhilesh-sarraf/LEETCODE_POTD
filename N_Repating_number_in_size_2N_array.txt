class Solution {
public:
    int repeatedNTimes(vector<int>& nums) {
        
        // n is the size of the array (array size = 2N)
        int n = nums.size();
        
        /*
         APPROACH EXPLANATION:
         ---------------------
         - One element appears exactly N times in an array of size 2N.
         - All other elements appear only once.
         - Due to this strong constraint, the repeated element
           MUST appear close to itself.
         - It is guaranteed to repeat within the next 1, 2, or 3 positions.
         
         This allows us to solve the problem in:
         - Time Complexity: O(n)
         - Space Complexity: O(1)
        */

        // Traverse the array
        for(int i = 0; i < n - 1; i++) {

            // Case 1: Check adjacent elements
            if(nums[i] == nums[i + 1])
                return nums[i];

            // Case 2: Check with a gap of 1 (i and i+2)
            // i+2 < n ensures we do not go out of bounds
            if(i + 2 < n && nums[i] == nums[i + 2])
                return nums[i];

            // Case 3: Check with a gap of 2 (i and i+3)
            // i+3 < n ensures safe array access
            if(i + 3 < n && nums[i] == nums[i + 3])
                return nums[i];
        }

        // Safety return (problem guarantees a valid answer, so this line is never reached)
        return -1;
    }
};